"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rx_1 = require("rx");
var ALL = '__ALL__';
var Emitter = /** @class */ (function () {
    function Emitter() {
        this.emitterState = {
            observables: new Map,
            observers: new Map
        };
    }
    /**
     * Emit an event (silently fails if no listeners are hooked up yet)
     */
    Emitter.prototype.emit = function (type, data) {
        if (this.hasChannel(type)) {
            this.emitterState.observers.get(type).forEach(function (_) { return _.onNext(data); });
        }
        if (this.hasChannel(ALL)) {
            this.emitterState.observers.get(ALL).forEach(function (_) { return _.onNext(data); });
        }
        return this;
    };
    /**
     * Subscribe to an event
     */
    Emitter.prototype.on = function (type) {
        return this.createChannel(type);
    };
    /**
     * Subscribe to all events
     */
    Emitter.prototype.all = function () {
        return this.createChannel(ALL);
    };
    ///////////////////// privates /////////////////////
    Emitter.prototype.createChannel = function (type) {
        var _this = this;
        if (!this.emitterState.observers.has(type)) {
            this.emitterState.observers.set(type, []);
        }
        if (!this.emitterState.observables.has(type)) {
            this.emitterState.observables.set(type, []);
        }
        var observable = rx_1.Observable
            .create(function (_) { return _this.emitterState.observers.get(type).push(_); })
            .finally(function () { return _this.deleteChannel(type, observable); });
        this.emitterState.observables.get(type).push(observable);
        return observable;
    };
    Emitter.prototype.deleteChannel = function (type, observable) {
        if (!this.emitterState.observables.has(type)) {
            return;
        }
        var array = this.emitterState.observables.get(type);
        var index = array.indexOf(observable);
        if (index < 0) {
            return;
        }
        array.splice(index, 1);
        if (!array.length) {
            this.emitterState.observables.delete(type);
            this.emitterState.observers.delete(type);
        }
    };
    Emitter.prototype.hasChannel = function (type) {
        return this.emitterState.observables.has(type);
    };
    return Emitter;
}());
exports.Emitter = Emitter;
//# sourceMappingURL=index.js.map